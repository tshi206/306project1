package Solver;

import java.util.Iterator;
import java.util.Set;
import java.util.stream.IntStream;

import CommonInterface.ISearchState;
import Graph.EdgeWithCost;
import Graph.Vertex;
import Graph.Graph;

import lombok.Data;
import pt.runtime.CurrentTask;
import pt.runtime.ParaTask;
import pt.runtime.TaskID;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;

public class DFSPar extends DFSolver{
	
	public DFSPar(Graph<Vertex, EdgeWithCost<Vertex>> graph, int processorCount, int parNumber) {
		super(graph, processorCount,parNumber);
		
	}


	@Override
	public void doSolve() {
		SearchState.initialise(graph);
		SearchState nullstate = new SearchState();
		calculatingnNextLayerSearchingState(nullstate);
		
		ParaTask.setScheduling(ParaTask.ScheduleType.WorkSharing);
		System.out.println("Thread size: "+ParaTask.getThreadPoolSize(ParaTask.ThreadPoolType.MULTI));
		TaskIDGroup g = this.buildTask(parallelTask);
		
		try {
			g.waitTillFinished();
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		scheduleVertices(currBestState);
	}
	
	TASK(*) public void buildTask(ConcurrentLinkedQueue<SearchState> states) {
		SearchState currentState = null;
		while((currentState = states.poll()) != null) {
	        long id = Thread.currentThread().getId();
            System.out.println("[thread "+id+"]");
			solving(currentState);
		}
	}
	
	
	
}