package Solver;

import java.util.Iterator;
import java.util.Set;
import java.util.stream.IntStream;

import CommonInterface.ISearchState;
import Graph.EdgeWithCost;
import Graph.Vertex;
import Graph.Graph;

import lombok.Data;
import pt.runtime.TaskID;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;

public class DFSPar extends DFSolver{
	
	private static int bound = Integer.MAX_VALUE;
	private static SearchState currBestState;
	private static int currUpperBound = Integer.MAX_VALUE;
	
	public DFSPar(Graph<Vertex, EdgeWithCost<Vertex>> graph, int processorCount, int parNumber) {
		super(graph, processorCount,parNumber);
	}


	@Override
	public void doSolve() {
		SearchState.initialise(graph);
		SearchState nullstate = new SearchState();
		calculatingFirstLayerSearchingState(nullstate);
		
//		TaskID id= this.buildTask(nullstate);
//		try {
//			id.waitTillFinished();
//		} catch (Exception e) {
//			e.printStackTrace();
//		}
		solving(nullstate);
		
		scheduleVertices(currBestState);
	}
	
	TASK public void buildTask(SearchState state) {
		solving(state);
	}
	
	private void solving(SearchState s){
		Set<Vertex> legalVerticesSet = s.getLegalVertices();
		for(Iterator<Vertex> it = legalVerticesSet.iterator();it.hasNext();) {
			Vertex v = it.next();
			for(int processorC = 0; processorC<processorCount; processorC++) {
				SearchState next = new SearchState(s, v, processorC);
				if (next.getUnderestimate() > currUpperBound){
					return;
				}
				if (next.getNumVertices() == graph.getVertices().size()){
					updateLog(next);
					return;
				}
				solving(next);
			}
		}
	}
	
	
}